/*
 * Copyright (C) 2018, Jacques Van Damme.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef FORMATTER_H
#define FORMATTER_H

#include <array>
#include <deque>
#include <forward_list>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <set>
#include <string.h>
#include <string>
#include <unordered_set>
#include <vector>

namespace tsioImplementation
{
enum {
    numericfill = 1,
    alfafill = numericfill << 1,
    signedNumber = numericfill << 1,
    plusIfPositive = signedNumber << 1,
    spaceIfPositive = plusIfPositive << 1,
    leftJustify = spaceIfPositive << 1,
    centerJustify = leftJustify << 1,
    upcase = centerJustify << 1,
    alternative = upcase << 1,
    nice = alternative << 1
};

struct FormatState
{
    const char* prefix;
    const char* suffix;
    unsigned width;
    unsigned precision;
    unsigned type;
    unsigned position;
    unsigned widthPosition;
    unsigned precisionPosition;
    unsigned prefixSize;
    unsigned postfixSize;
    bool widthDynamic;
    bool precisionDynamic;
    bool widthGiven;
    bool precisionGiven;
    bool active;
    bool isContainerFormat;
    char formatSpecifier;
    char fillCharacter;

    mutable char buf[31]; // enough for 5 flags, 2 ints, a dot and a specifier.

    FormatState() = default;
    FormatState(const char*& format);

    void parse(const char*& format);

    const char* unParse() const;

    void reset()
    {
        prefix = nullptr;
        suffix = nullptr;
        width = 0;
        precision = 0;
        type = 0;
        position = 0;
        widthPosition = 0;
        precisionPosition = 0;
        prefixSize = 0;
        postfixSize = 0;
        widthGiven = false;
        precisionGiven = false;
        widthDynamic = false;
        precisionDynamic = false;
        isContainerFormat = false;
        active = false;
        formatSpecifier = 0;
        fillCharacter = ' ';
    }
};

struct Format
{
    Format(std::string& d, const char* f) : format(f), dest(d)
    {
    }

    struct StackElement
    {
        StackElement(const char* f, size_t c) : format(f), count(c)
        {
        }

        const char* format;
        size_t count;
    };

    void push(size_t count)
    {
        if (count != 0) {
            stack.emplace_back(format, count - 1);
        }
    }

    bool repeat()
    {
        if (!stack.empty()) {
            if (stack.back().count-- == 0) {
                stack.pop_back();
                return false;
            }

            format = stack.back().format;
            return true;
        }

        return false;
    }

    void skipToFormat();
    void copyToFormat();
    void parse();

    const char* format;
    FormatState state;
    std::string& dest;
    std::vector<StackElement> stack;
};

void outputString(std::string& dest,
                  const char* text,
                  size_t size,
                  int minSize,
                  int maxSize,
                  unsigned type,
                  char fillCharacter);

inline void outputString(std::string& dest,
                         const char* text,
                         int minSize,
                         int maxSize,
                         unsigned type,
                         char fillCharacter)
{
    outputString(dest, text, strlen(text), minSize, maxSize, type, fillCharacter);
}

void outputNumber(std::string& dest,
                  long long pNumber,
                  int base,
                  int size,
                  int precision,
                  unsigned type,
                  char fillCharacter);

void printfDetail(Format& format, const std::string& value);
void printfDetail(Format& format, const char* value);
void printfDetail(Format& format, double value);
void printfDetail(Format& format, float value);
void printfDetail(Format& format, bool value);

template <typename T>
inline void printfDetail(Format& format, const T& value)
{
    FormatState& state = format.state;
    std::string& dest = format.dest;
    typename std::make_signed<T>::type sValue = value;
    typename std::make_unsigned<T>::type uValue = value;
    char spec = state.formatSpecifier;
    char fillCharacter = state.fillCharacter;

    auto type = state.type;

    if ((type & numericfill) && state.precisionGiven) {
        type &= ~numericfill;
        fillCharacter = ' ';
    }

    switch (spec) {
        case 'b':
            outputNumber(dest, uValue, 2, state.width, state.precision, type, fillCharacter);
            break;

        case 'c': {
            char c = char(value);
            outputString(dest,
                         &c,
                         1,
                         state.width,
                         state.precisionGiven ? (state.precision > 0 ? state.precision : 1)
                                              : std::numeric_limits<int>::max(),
                         type,
                         fillCharacter);
        }

        break;

        case 'C': {
            char c = char(value);
            outputString(dest,
                         &c,
                         1,
                         state.width,
                         state.precisionGiven ? (state.precision > 0 ? state.precision : 1)
                                              : std::numeric_limits<int>::max(),
                         type | nice,
                         fillCharacter);

        }

        break;

        case 'd':
        case 'i':
            outputNumber(dest,
                         sValue,
                         10,
                         state.width,
                         state.precisionGiven ? state.precision : 1,
                         type | signedNumber,
                         fillCharacter);
            break;

        case 's':
            if (std::is_signed<T>::value) {
                outputNumber(dest,
                             sValue,
                             10,
                             state.width,
                             state.precisionGiven ? state.precision : 1,
                             type | signedNumber,
                             fillCharacter);
            } else {
                outputNumber(dest,
                             uValue,
                             10,
                             state.width,
                             state.precisionGiven ? state.precision : 1,
                             type,
                             fillCharacter);
            }

            break;

        case 'o':
            outputNumber(dest,
                         uValue,
                         8,
                         state.width,
                         state.precisionGiven ? state.precision : 1,
                         type,
                         fillCharacter);

            break;

        case 'u':
            outputNumber(dest,
                         uValue,
                         10,
                         state.width,
                         state.precisionGiven ? state.precision : 1,
                         type,
                         fillCharacter);

            break;

        case 'x':
            outputNumber(dest,
                         uValue,
                         16,
                         state.width,
                         state.precisionGiven ? state.precision : 1,
                         type,
                         fillCharacter);

            break;

        case 'X':
            outputNumber(dest,
                         uValue,
                         16,
                         state.width,
                         state.precisionGiven ? state.precision : 1,
                         type | upcase,
                         fillCharacter);

            break;

        case 'n':
            std::cerr << "TSIO: Did you forget to specify the parameter for '%n' by pointer?" << std::endl;

        default:
            std::cerr << "TSIO: Invalid format '" << spec << "' for integeral value" << std::endl;
    }
}

template <typename T>
inline void printfDetail(Format& format, T* value)
{
    FormatState& state = format.state;
    std::string& dest = format.dest;
    char spec = state.formatSpecifier;
    uintptr_t pValue = uintptr_t(value);

    switch (spec) {
        case 'p':
            outputNumber(dest,
                         pValue,
                         16,
                         state.width,
                         state.precision,
                         state.type | alternative,
                         state.fillCharacter);

            break;

        case 'n':
            using baseType = typename std::remove_pointer<T>::type;

            *value = baseType(dest.size());

            break;

        default:
            printfDetail(format, static_cast<uintptr_t>(pValue));
    }
}

template <typename T>
inline void printfDetail(Format& format, const T* value)
{
    FormatState& state = format.state;
    std::string& dest = format.dest;
    char spec = state.formatSpecifier;
    uintptr_t pValue = uintptr_t(value);

    switch (spec) {
        case 'p':
            outputNumber(dest,
                         pValue,
                         16,
                         state.width,
                         state.precision,
                         state.type | alternative,
                         state.fillCharacter);

            break;

        default:
            printfDetail(format, static_cast<uintptr_t>(pValue));
    }
}

template <typename T>
inline void printfDetail(Format& format, const std::set<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T>
inline void printfDetail(Format& format, const std::multiset<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T>
inline void printfDetail(Format& format, const std::unordered_set<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T>
inline void printfDetail(Format& format, const std::unordered_multiset<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T>
inline void printfDetail(Format& format, const std::deque<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T>
inline void printfDetail(Format& format, const std::list<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T>
inline void printfDetail(Format& format, const std::forward_list<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T>
inline void printfDetail(Format& format, const std::vector<T>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template <typename T, size_t N>
inline void printfDetail(Format& format, const std::array<T, N>& value)
{
    for (const auto& v : value) {
        printfDetail(format, v);
    };
}

template<std::size_t I = 0, typename... Tp>
inline typename std::enable_if<I == sizeof...(Tp), void>::type
tupleDetail(Format& format, const std::tuple<Tp...>& t)
{ }

template<std::size_t I = 0, typename... Tp>
inline typename std::enable_if<I < sizeof...(Tp), void>::type
tupleDetail(Format& format, const std::tuple<Tp...>& t)
{
    printfDetail(format, std::get<I>(t));
    tupleDetail<I + 1, Tp...>(format, t);
}

template <typename... Ts>
inline void printfDetail(Format& format, const std::tuple<Ts...>& value)
{
    tupleDetail(format, value);
}

template <typename T, typename enable = void>
struct ToSpec
{
    int operator()(const T&)
    {
        std::cerr << "TSIO: invalid conversion" << std::endl;
        return 0;
    }
};

template <typename T>
struct ToSpec<T, typename std::enable_if<std::is_integral<T>::value>::type>
{
    int operator()(const T& value)
    {
        return int(value);
    }
};

void skipAfter(const char*& format, char startChar, char endChar);

template <typename T, typename enable = void>
struct ContainerDetail;


template <typename T>
struct ContainerDetail<T, typename std::enable_if<!std::is_class<T>::value && !std::is_array<T>::value>::type>
{
    void operator()(Format& format, const T& value)
    {
        FormatState& state = format.state;
        std::string& dest = format.dest;

        if (state.prefixSize != 0) {
            dest.append(state.prefix, state.prefixSize);
        }

        printfDetail(format, value);

        if (state.postfixSize != 0 && !(state.type & alternative)) {
            dest.append(state.suffix, state.postfixSize);
        }
    }
};

template <typename T>
struct ContainerDetail<T, typename std::enable_if<std::is_class<T>::value || std::is_array<T>::value>::type>
{
    void operator()(Format& format, const T& value)
    {
        FormatState& state = format.state;
        std::string& dest = format.dest;

        using std::begin;
        using std::end;

        for (auto b = begin(value), e = end(value); b != e;) {
            if (state.prefixSize != 0) {
                dest.append(state.prefix, state.prefixSize);
            }

            printfDetail(format, *b);

            ++b;

            if (b != e || (state.postfixSize != 0 && !(state.type & alternative))) {
                dest.append(state.suffix, state.postfixSize);
            }
        }
    }
};

template <typename T>
void containerDetail(Format& format, const T& value)
{
    ContainerDetail<T> c;

    c(format, value);
}

template<std::size_t I = 0, typename... Tp>
inline typename std::enable_if<I == sizeof...(Tp), void>::type
tupleContainerDetail(Format& format, const std::tuple<Tp...>& t)
{ }

template<std::size_t I = 0, typename... Tp>
inline typename std::enable_if<I < sizeof...(Tp), void>::type
tupleContainerDetail(Format& format, const std::tuple<Tp...>& t)
{
    FormatState& state = format.state;
    std::string& dest = format.dest;

    if (state.prefixSize != 0) {
        dest.append(state.prefix, state.prefixSize);
    }

    printfDetail(format, std::get<I>(t));
    if (I != sizeof...(Tp) - 1 || (state.postfixSize != 0 && !(state.type & alternative))) {
        dest.append(state.suffix, state.postfixSize);
    }

    tupleContainerDetail<I + 1, Tp...>(format, t);
}

template <typename... Ts>
void containerDetail(Format& format, const std::tuple<Ts...>& value)
{
    tupleContainerDetail(format, value);
}

template <typename T>
void printfOne(Format& format, const T& value)
{
    ToSpec<T> toSpec;
    FormatState& state = format.state;

    if (state.formatSpecifier == 0) {
        std::cerr << "TSIO: Extraneous parameter or missing format specifier." << std::endl;
        return;
    }

    if (state.active) {
        if (state.widthDynamic) {
            int spec = toSpec(value);

            if (spec < 0) {
                state.width = -spec;
                state.type |= leftJustify;
                if (state.type & numericfill) {
                    state.type &= ~numericfill;
                    state.fillCharacter = ' ';
                }
            } else {
                state.width = spec;
            }

            state.widthDynamic = false;
            return;
        }

        if (state.precisionDynamic) {
            int spec = toSpec(value);

            if (spec < 0) {
                state.precisionGiven = false;
            } else {
                state.precision = spec;
            }

            state.precisionDynamic = false;
            return;
        }
    }

    while (state.formatSpecifier == '{') {
        if (state.width == 0) {
            skipAfter(format.format, '{', '}');
        } else {
            format.push(state.width);
        }

        format.parse();

        if (state.formatSpecifier == '{' && state.active) {
            int spec = toSpec(value);

            if (spec < 0) {
                spec = 0;
            }

            state.width = spec;
            return;
        }
    }

    if (state.isContainerFormat) {
        containerDetail(format, value);
    } else {
        printfDetail(format, value);
    }

    format.parse();
}

#if __cplusplus < 201703L
inline void printfNth(Format&, size_t)
{
    std::cerr << "TSIO: Invalid position in format." << std::endl;
}

template <typename T, typename... Ts>
void printfNth(Format& format, size_t index, const T& t, const Ts&... ts)
{
    if (index == 1) {
        printfDetail(format, t);
    } else {
        printfNth(format, index - 1, ts...);
    }
}
inline void readSpecNum(int& dest, FormatState&, size_t)
{
    std::cerr << "TSIO: Invalid position in format." << std::endl;
    dest = 0;
}

template <typename T, typename... Ts>

void readSpecNum(int& dest, FormatState& state, size_t index, const T& t, const Ts&... ts)
{
    ToSpec<T> toSpec;

    if (index == 1) {
        dest = toSpec(t);
    } else {
        readSpecNum(dest, state, index - 1, ts...);
    }
}
#else
template <typename T, typename... Ts>
bool printfDispatch(Format& format, size_t index, const T& t, const Ts&... ts)
{
    if (index == 1) {
        printfDetail(format, t);
        return true;
    } else {
        return false;
    }
}

template <typename... Ts>
void printfNth(Format& format, size_t index, const Ts&... ts)
{
    auto i = format.state.position + 1;

    static_cast<void>(((i--, printfDispatch(format, i, ts)) || ...));
}

template <typename T, typename... Ts>
bool readSpecNumDispatch(int& dest, FormatState& state, size_t index, const T& t, const Ts&... ts)
{
    ToSpec<T> toSpec;

    if (index == 1) {
        dest = toSpec(t);
        return true;
    } else {
        return false;
    }
}

template <typename... Ts>
void readSpecNum(int& dest, FormatState& state, size_t index, const Ts&... ts)
{
    auto i = index + 1;

    static_cast<void>(((i--, readSpecNumDispatch(dest, state, i, ts)) || ...));
}

#endif

template <typename... Ts>
void printfPositionalOne(Format& format, const Ts&... ts)
{
    FormatState& state = format.state;

    if (state.formatSpecifier == 0) {
        std::cerr << "TSIO: Extraneous parameter or missing format specifier." << std::endl;
        return;
    }

    if (state.position == 0) {
        std::cerr << "TSIO: Positional arguments can not be mixed with sequential arguments." << std::endl;
        return;
    }

    if (state.active) {
        if (state.widthDynamic) {
            int spec = 0;

            readSpecNum(spec, state, state.widthPosition, ts...);

            if (spec < 0) {
                state.width = -spec;
                state.type |= leftJustify;
                if (state.type & numericfill) {
                    state.type &= ~numericfill;
                    state.fillCharacter = ' ';
                }
            } else {
                state.width = spec;
            }
        }

        if (state.precisionDynamic) {
            int spec = 0;

            readSpecNum(spec, state, state.precisionPosition, ts...);

            if (spec < 0) {
                state.precisionGiven = false;
            } else {
                state.precision = spec;
            }
        }
    }

    printfNth(format, state.position, ts...);

    format.parse();
}

#if __cplusplus < 201703L
template <typename T, typename... Ts>
inline void unpack(Format& format, const T& t, const Ts&... ts)
{
    printfOne(format, t);
    unpack(format, ts...);
}

inline void unpack(Format&)
{
    // nop
}
#endif

template <typename... Ts>
void addsprintf(std::string& dest, const char* f, const Ts&... ts)
{
    Format format(dest, f);
    FormatState& state = format.state;

    format.parse();

    while (state.formatSpecifier == '{' && !state.active) {
        if (state.width == 0) {
            skipAfter(format.format, '{', '}');
        } else {
            format.push(state.width);
        }

        format.parse();
    }

    if (state.position != 0 || state.widthPosition != 0 || state.precisionPosition != 0) {
        do {
            while (state.formatSpecifier == '{') {
                if (state.widthDynamic) {
                    int spec = 0;

                    readSpecNum(spec, state, state.widthPosition, ts...);

                    if (spec < 0) {
                        spec = 0;
                    }

                    state.width = spec;
                }

                if (state.width == 0) {
                    skipAfter(format.format, '{', '}');
                } else {
                    format.push(state.width);
                }

                format.parse();
            }

            if (state.formatSpecifier != 0) {
                printfPositionalOne(format, ts...);
            }
        } while (*format.format != 0);
    } else {

#if __cplusplus >= 201703L
        (printfOne(format, ts), ...);
#else
        unpack(format, ts...);
#endif

        while (state.formatSpecifier == '{') {
            if (state.width == 0) {
                skipAfter(format.format, '{', '}');
            } else {
                format.push(state.width);
            }

            format.parse();

            if (state.formatSpecifier == '{' && state.active) {
                break;
            }
        }

        if (state.formatSpecifier != 0) {
            std::cerr << "TSIO: Missing parameter or extraneous format specifier." << std::endl;
        }
    }
}
};

namespace tsio
{
class fmt
{
public:
    fmt(const char* format = nullptr)
    {
        initialize(format);
    }

    fmt(const std::string& format)
    {
        initialize(format.c_str());
    }

    std::ostream& operator()(std::ostream& out) const;

private:
    void initialize(const char* format);

    tsioImplementation::FormatState state;
};

inline std::ostream& operator<<(std::ostream& out, const fmt& f)
{
    return f(out);
}

template <typename... Arguments>
int sprintf(std::string& dest, const char* format, const Arguments&... arguments)
{
    dest.clear();

    tsioImplementation::addsprintf(dest, format, arguments...);

    return int(dest.size());
}

template <typename... Arguments>
int addsprintf(std::string& dest, const char* format, const Arguments&... arguments)
{
    auto startSize = dest.size();

    tsioImplementation::addsprintf(dest, format, arguments...);

    return int(dest.size() - startSize);
}

template <typename... Arguments>
int fprintf(std::ostream& os, const char* format, const Arguments&... arguments)
{
    std::string tmp;

    tsioImplementation::addsprintf(tmp, format, arguments...);
    os << tmp;

    return int(tmp.size());
}

template <typename... Arguments>
int oprintf(const char* format, const Arguments&... arguments)
{
    std::string tmp;

    tsioImplementation::addsprintf(tmp, format, arguments...);
    std::cout << tmp;

    return int(tmp.size());
}

template <typename... Arguments>
int eprintf(const char* format, const Arguments&... arguments)
{
    std::string tmp;

    tsioImplementation::addsprintf(tmp, format, arguments...);
    std::cerr << tmp;

    return int(tmp.size());
}

template <typename... Arguments>
std::string fstring(const char* format, const Arguments&... arguments)
{
    std::string tmp;

    tsioImplementation::addsprintf(tmp, format, arguments...);

    return tmp;
}
};

#endif
