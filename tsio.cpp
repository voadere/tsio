/*
 * Copyright (C) 2018, Jacques Van Damme.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "tsio.h"
#include <time.h>

#if defined(_MSC_VER)
#define ALWAYS_INLINE __forceinline
#else
#define ALWAYS_INLINE __attribute__((always_inline))
#endif

static ALWAYS_INLINE void copy(char* dest, const char* src, unsigned size)
{
    switch (size) {
        case 4:
            dest[3] = src[3];
            // Fallthru
        case 3:
            dest[2] = src[2];
            // Fallthru
        case 2:
            dest[1] = src[1];
            // Fallthru
        case 1:
            dest[0] = src[0];
            // Fallthru
        case 0:
            return;
        default:
            memcpy(dest, src, size);
    }
}

static ALWAYS_INLINE void fill(char* dest, char c, unsigned size)
{
    switch (size) {
        case 4:
            dest[3] = c;
            // Fallthru
        case 3:
            dest[2] = c;
            // Fallthru
        case 2:
            dest[1] = c;
            // Fallthru
        case 1:
            dest[0] = c;
            // Fallthru
        case 0:
            return;
        default:
            memset(dest, c, size);
    }
}

void tsioImplementation::outputString(std::string& dest,
                                      const char* text,
                                      size_t s,
                                      int minSize,
                                      int maxSize,
                                      unsigned type,
                                      char fillCharacter)
{
    if (text == nullptr) {
        return;
    }

    std::string tmp;
    int size = int(s);

    if (type & nice) {
        if (type & alternative) {
            for (int i = 0; i < size; ++i) {
                char c = text[i];

                char buf[5];
                const char* pt;

                switch (c) {
                    case '\a':
                        pt = "\\a";
                        break;

                    case '\b':
                        pt = "\\b";
                        break;

                    case '\f':
                        pt = "\\f";
                        break;

                    case '\n':
                        pt = "\\n";
                        break;

                    case '\r':
                        pt = "\\r";
                        break;

                    case '\t':
                        pt = "\\t";
                        break;

                    case '\v':
                        pt = "\\v";
                        break;

                    case '\\':
                        pt = "\\\\";
                        break;

                    case '\"':
                        pt = "\\\"";
                        break;

                    case '\'':
                        pt = "\\\'";
                        break;

                    default:
                        if (c < ' ' || c > '~') {
                            buf[0] = '\\';
                            buf[1] = char(((c >> 6) & 0x3) + '0');
                            buf[2] = char(((c >> 3) & 0x7) + '0');
                            buf[3] = char(((c)&0x7) + '0');
                            buf[4] = '\0';
                        } else {
                            buf[0] = c;
                            buf[1] = '\0';
                        }

                        pt = buf;
                }

                tmp += pt;
            }
        } else {
            for (int i = 0; i < size; ++i) {
                char c = text[i];

                tmp.push_back((c < ' ' || c > '~') ? '.' : c);
            }
        }

        text = tmp.c_str();
        size = tmp.size();
    }

    int cnt = 0;

    if (size > maxSize) {
        size = maxSize;
    }

    if (minSize <= size) {
        dest.append(text, size);
    } else {
        if (!(type & alfafill)) {
            fillCharacter = ' ';
        }

        size_t destSize = dest.size();

        dest.append(minSize, fillCharacter);

        char* pt = &dest[destSize];

        if (type & leftJustify) {
            copy(pt, text, size);
        } else if (type & centerJustify) {
            size_t offset = (minSize - cnt - size) / 2;

            copy(pt + offset, text, size);
        } else {
            size_t offset = minSize - size;

            copy(pt + offset, text, size);
        }
    }
}

void tsioImplementation::outputNumber(std::string& dest,
                                      long long pNumber,
                                      int base,
                                      int size,
                                      int precision,
                                      unsigned type,
                                      char fillCharacter)
{
    unsigned long long number;
    const size_t bufSize = 134; // allow for 128 binary digits plus radix indicator and sign
    char buf[bufSize * 2];
    char prefix[4];
    size_t prefixSize = 0;
    const char* digitPairs = "0001020304050607080910111213141516171819"
                             "2021222324252627282930313233343536373839"
                             "4041424344454647484950515253545556575859"
                             "6061626364656667686970717273747576777879"
                             "8081828384858687888990919293949596979899";

    if (precision < 0) {
        precision = 0;
    }

    char* actualPointer = buf + bufSize;
    char* precisionPointer = actualPointer - precision;

    number = pNumber;

    if (type & signedNumber) {
        if (pNumber < 0) {
            prefix[prefixSize++] = '-';
            number = -pNumber;
        } else if (type & plusIfPositive) {
            prefix[prefixSize++] = '+';
        } else if (type & spaceIfPositive) {
            prefix[prefixSize++] = ' ';
        }
    }

    if (precision != 0 || pNumber != 0) {
        switch (base) {
            case 2:
                do {
                    *(--actualPointer) = char((number & 1) + '0');
                    number >>= 1;
                } while (number != 0);

                while (actualPointer > precisionPointer) {
                    *(--actualPointer) = '0';
                }

                if (type & alternative && pNumber != 0) {
                    prefix[prefixSize++] = '0';
                    prefix[prefixSize++] = (type & upcase) ? 'B' : 'b';
                }

                break;

            case 8:
                do {
                    *(--actualPointer) = char((number & 7) + '0');
                    number >>= 3;
                } while (number != 0);

                while (actualPointer > precisionPointer) {
                    *(--actualPointer) = '0';
                }

                if (type & alternative) {
                    if (*actualPointer != '0') {
                        prefix[prefixSize++] = '0';
                    }
                }

                break;

            case 16: {
                const char* lowDigits = "0123456789abcdef";
                const char* upDigits = "0123456789ABCDEF";
                const char* digits = (type & upcase) ? upDigits : lowDigits;

                do {
                    *(--actualPointer) = digits[number & 15];
                    number >>= 4;
                } while (number != 0);

                while (actualPointer > precisionPointer) {
                    *(--actualPointer) = '0';
                }

                if (type & alternative && pNumber != 0) {
                    prefix[prefixSize++] = '0';
                    prefix[prefixSize++] = (type & upcase) ? 'X' : 'x';
                }
            }

            break;

            case 10:
                while (unsigned(number) != number) {
                    unsigned long long q = number / 100;
                    unsigned long long r = (number % 100) * 2;

                    *(--actualPointer) = digitPairs[r + 1];
                    *(--actualPointer) = digitPairs[r];

                    number = q;
                }

                unsigned uNumber = unsigned(number);

                while (uNumber >= 100) {
                    unsigned q = uNumber / 100;
                    unsigned r = (uNumber % 100) * 2;

                    *(--actualPointer) = digitPairs[r + 1];
                    *(--actualPointer) = digitPairs[r];

                    uNumber = q;
                }

                if (uNumber >= 10) {
                    unsigned long long r = uNumber * 2;

                    *(--actualPointer) = digitPairs[r + 1];
                    *(--actualPointer) = digitPairs[r];
                } else {
                    *(--actualPointer) = char(uNumber + '0');
                }

                while (actualPointer > precisionPointer) {
                    *(--actualPointer) = '0';
                }

                break;
        }
    } else {
        /// This is a hack to overcome an inconsistency between '%.x' and '%.o' formatting.
        if (base == 8 && (type & alternative)) {
            prefix[prefixSize++] = '0';
        }
    }

    auto actualDigits = buf + bufSize - actualPointer;
    auto bytesNeeded = actualDigits + prefixSize;

    if (size_t(size) <= bytesNeeded) {
        if (prefixSize != 0) {
            dest.append(prefix, prefixSize);
        }

        dest.append(actualPointer, actualDigits);
    } else {
        char fillChar = (type & (alfafill | numericfill)) ? fillCharacter : ' ';
        if (bytesNeeded < bufSize) {
            char* pt;

            if (type & leftJustify) {
                pt = actualPointer - prefixSize;

                copy(pt, prefix, prefixSize);
                fill(buf + bufSize, fillChar, size - bytesNeeded);
            } else if (type & centerJustify) {
                size_t offset = (size - bytesNeeded) / 2;
                pt = actualPointer - prefixSize - offset;

                copy(actualPointer - prefixSize, prefix, prefixSize);
                fill(pt, fillChar, offset);
                fill(buf + bufSize, fillChar, (size - bytesNeeded) - offset);
            } else if (type & numericfill) {
                pt = buf + bufSize - size;

                copy(pt, prefix, prefixSize);
                fill(pt + prefixSize, fillChar, size - bytesNeeded);
            } else {
                pt = buf + bufSize - size;

                copy(actualPointer - prefixSize, prefix, prefixSize);
                fill(pt, fillChar, size - bytesNeeded);
            }

            dest.append(pt, size);
        } else {
            size_t destSize = dest.size();

            dest.append(size, fillChar);

            char* pt = &dest[destSize];

            if (type & leftJustify) {
                copy(pt, prefix, prefixSize);
                copy(pt + prefixSize, actualPointer, actualDigits);
            } else if (type & centerJustify) {
                size_t offset = (size - bytesNeeded) / 2;

                copy(pt + prefixSize, prefix, prefixSize);
                copy(pt + offset + prefixSize, actualPointer, bytesNeeded);
            } else if (type & numericfill) {
                copy(pt, prefix, prefixSize);
                copy(pt + size - actualDigits, actualPointer, actualDigits);
            } else {
                copy( pt + size - bytesNeeded, prefix, prefixSize);
                copy( pt + size - actualDigits, actualPointer, actualDigits);
            }
        }
    }
}

static bool isValidFormatSpecifier(unsigned c)
{
    switch(c) {
        case '(':
        case ')':
        case '<':
        case '>':
        case 'A':
        case 'B':
        case 'C':
        case 'E':
        case 'F':
        case 'G':
        case 'S':
        case 'X':
        case '[':
        case ']':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'i':
        case 'n':
        case 'o':
        case 'p':
        case 's':
        case 'u':
        case 'x':
        case '{':
        case '}':
            return true;
    }

    return false;
}

void tsioImplementation::FormatState::parse(const char*& f)
{
    const char* format = f;

    unsigned char ch = *(format++);

    if (ch >= '1' && ch <= '9') {
        unsigned number = ch - '0';

        auto pt = format;

        for (; *pt >= '0' && *pt <= '9'; ++pt) {
            number = number * 10 + (*pt - '0');
        }

        if (*pt == '$') {
            position = number;
            format = pt + 1;
            ch = *(format++);
        } else {
            width = number;
            setWidthGiven();
            format = pt;
            ch = *(format++);
        }
    }

    if (isValidFormatSpecifier(ch)) {
        formatSpecifier = ch;
        f = format;
        return;
    }

    if (!widthGiven()) {
        char alfaFill = ' ';
        char numericFill = ' ';

        for (;;) {
            if (ch == '0') {
                type |= numericfill;
                numericFill = '0';
            } else if (ch == '-') {
                type |= leftJustify;
            } else if (ch == '^') {
                type |= centerJustify;
            } else if (ch == '+') {
                type |= plusIfPositive;
            } else if (ch == ' ') {
                type |= spaceIfPositive;
            } else if (ch == '#') {
                type |= alternative;
            } else if (ch == '\'') {
                type |= numericfill;

                if (*format != 0) {
                    numericFill = *(format++);
                }
            } else if (ch == '\"') {
                type |= alfafill;

                if (*format != 0) {
                    alfaFill = *(format++);
                }
            } else {
                break;
            }

            ch = *(format++);
        }

        if ((type & (plusIfPositive | spaceIfPositive)) == (plusIfPositive | spaceIfPositive)) {
            type &= ~spaceIfPositive;
        }

        if ((type & (leftJustify | numericfill)) == (leftJustify | numericfill)) {
            type &= ~numericfill;
        }

        if ((type & (centerJustify | numericfill)) == (centerJustify | numericfill)) {
            type &= ~numericfill;
        }

        if ((type & (alfafill | numericfill)) == (alfafill | numericfill)) {
            type &= ~alfafill;
        }

        if (type & numericfill) {
            fillCharacter = numericFill;
        } else if (type & alfafill) {
            fillCharacter = alfaFill;
        }

        if (ch == '*') {
            setWidthDynamic();
            setWidthGiven();
            setActive();
            ch = *(format++);

            if (unsigned(ch - '0') < 9) {
                widthPosition = unsigned(ch - '0');
                ch = *(format++);

                while (unsigned(ch - '0') < 9) {
                    widthPosition = widthPosition * 10 + (unsigned(ch - '0'));
                    ch = *(format++);
                }

                if (ch == '$') {
                    ch = *(format++);
                }
            }
        } else {
            if (unsigned(ch - '0') < 9) {
                setWidthGiven();
                width = unsigned(ch - '0');
                ch = *(format++);

                while (unsigned(ch - '0') < 9) {
                    width = width * 10 + (unsigned(ch - '0'));
                    ch = *(format++);
                }
            }
        }
    }

    if (ch == '.') {
        ch = *(format++);
        setPrecisionGiven();

        if (ch == '*') {
            setPrecisionDynamic();
            setActive();
            ch = *(format++);

            if (unsigned(ch - '0') < 9) {
                precisionPosition = unsigned(ch - '0');
                ch = *(format++);

                while (unsigned(ch - '0') < 9) {
                    precisionPosition = precisionPosition * 10 + (unsigned(ch - '0'));
                    ch = *(format++);
                }

                if (ch == '$') {
                    ch = *(format++);
                }
            }
        }
        if (unsigned(ch - '0') < 9) {
            precision = unsigned(ch - '0');

            ch = *(format++);

            while (unsigned(ch - '0') < 9) {
                precision = precision * 10 + (unsigned(ch - '0'));
                ch = *(format++);
            }
        }
    }

    while (ch == 'h' || ch == 'j' || ch == 'l' || ch == 'L' || ch == 't' || ch == 'z') {
        ch = *(format++);
    }

    formatSpecifier = ch;
    if (ch == 0) {
        f = format - 1;
    } else {
        f = format;
    }
}

// unparse generates a standard format.  Extensions are mostly not generated.
const char* tsioImplementation::FormatState::unParse() const
{
    // the string is built back to front.
    buf[30] = 0;
    char* pt = buf + 30;

    *(--pt) = formatSpecifier;

    if (precisionGiven()) {
        if (widthDynamic()) {
            *(--pt) = '*';
        } else {
            unsigned tmp = precision;

            do {
                unsigned q = tmp / 10;
                unsigned r = tmp - q * 10;

                *(--pt) = char(r + '0');
                tmp = q;
            } while (tmp != 0);
        }

        *(--pt) = '.';
    }

    if (widthGiven()) {
        if (widthDynamic()) {
            *(--pt) = '*';
        } else {
            unsigned tmp = width;

            do {
                unsigned q = tmp / 10;
                unsigned r = tmp - q * 10;

                *(--pt) = char(r + '0');
                tmp = q;
            } while (tmp != 0);
        }
    }

    if (type != 0) {
        if (type & numericfill) {
            *(--pt) = '0';
        }

        if (type & plusIfPositive) {
            *(--pt) = '+';
        }

        if (type & spaceIfPositive) {
            *(--pt) = ' ';
        }

        if (type & leftJustify) {
            *(--pt) = '-';
        }

        if (type & alternative) {
            *(--pt) = '#';
        }
    }

    *(--pt) = '%';

    return pt;
}

tsioImplementation::FormatNode* tsioImplementation::Format::getNode()
{
    if (chuncks->index == chuncks->chunckSize - 1) {
        auto pt = new FormatNodes;

        pt->next = chuncks;
        chuncks = pt;
    }

    auto result = &chuncks->nodes[chuncks->index++];
    result->reset();
    return result;
}

void tsioImplementation::Format::skipToFormat()
{
    while (*format != 0) {
        if (*format == '%') {
            format++;
            return;
        }

        format++;
    }
}

tsioImplementation::FormatNode* tsioImplementation::Format::buildTree(bool& positional)
{
    FormatNode* result = nullptr;
    FormatNode* next = nullptr;

    while (*format != 0) {
        FormatNode* node = getNode();

        if (result == nullptr) {
            result = node;
            next = node;
        } else {
            next->next = node;
            next = node;
        }

        FormatState& state = node->state;

        state.prefix = format;
        skipToFormat();
        if (*format == 0) {
            state.prefixSize = unsigned(format - state.prefix);
        } else {
            state.prefixSize = unsigned(format - state.prefix - 1);
        }

        state.parse(format);
        if (state.position != 0 || state.widthPosition != 0 || state.precisionPosition != 0) {
            positional = true;
        }

        if (state.formatSpecifier == '}' || 
            state.formatSpecifier == ']' ||
            state.formatSpecifier == '>') {
            break;
        }

        if (state.formatSpecifier == '{' || 
            state.formatSpecifier == '[' ||
            state.formatSpecifier == '<') {
            node->child = buildTree(positional);
        }
    }

    return result;
}

tsioImplementation::FormatNode* tsioImplementation::Format::getNextSibling(
        FormatNode* node, bool first)
{
    if (node == nullptr) {
        return node;
    }

    if (!first) {
        node = node->next;
    }

    for (;;) {
        if (node == nullptr || node->state.active()) {
            return node;
        }

        FormatState& state = node->state;
        auto spec = state.formatSpecifier;

        if (spec == '%') {
            if (node->state.prefixSize != 0) {
                dest.append(node->state.prefix, node->state.prefixSize);
            }

            dest.push_back('%');
            node = node->next;

            continue;
        }

        if (spec == '{') {
            auto child = node->child;

            if (child->next == nullptr && child->state.formatSpecifier == '}') {
                if (node->state.prefixSize != 0) {
                    dest.append(node->state.prefix, node->state.prefixSize);
                }

                for (unsigned i = 0, c = node->state.width; i < c; ++i) {
                    dest.append(child->state.prefix, child->state.prefixSize);
                }

                node = node->next;

                continue;
            }
        }

        break;
    }

    return node;
}

void tsioImplementation::Format::getNextNode(bool first)
{
    if (nextNode == nullptr) {
        return;
    }

    if (!first) {
        nextNode = nextNode->next;
    }

    for (;;) {
        while (nextNode == nullptr && !stack.empty()) {
            auto& element = stack.back();

            if ((element.count--) == 0) {
                nextNode = element.node->next;
                stack.pop_back();
            } else {
                nextNode = element.node->child;
            }
        }

        if (nextNode == nullptr || nextNode->state.active()) {
            return;
        }

        FormatState& state = nextNode->state;
        auto spec = state.formatSpecifier;

        if (spec == '%') {
            if (nextNode->state.prefixSize != 0) {
                dest.append(nextNode->state.prefix, nextNode->state.prefixSize);
            }

            dest.push_back('%');
            nextNode = nextNode->next;

            continue;
        }

        if (spec == '{') {
            if (nextNode->state.prefixSize != 0) {
                dest.append(nextNode->state.prefix, nextNode->state.prefixSize);
            }

            auto child = nextNode->child;

            if (child->next == nullptr && child->state.formatSpecifier == '}') {
                for (unsigned i = 0, c = nextNode->state.width; i < c; ++i) {
                    dest.append(child->state.prefix, child->state.prefixSize);
                }

                nextNode = nextNode->next;

                continue;
            }

            push(state.width);
            nextNode = child;

            continue;
        }

        if (spec == '}' || spec == 0) {
            if (nextNode->state.prefixSize != 0) {
                dest.append(nextNode->state.prefix, nextNode->state.prefixSize);
            }

            nextNode = nextNode->next;

            continue;
        }

        break;
    }
}

void tsioImplementation::Format::printTree(std::ostream& os, FormatNode* node, unsigned indent)
{
    const auto& state = node->state;

    for (unsigned i = 0; i < indent; ++i) {
        os << ". ";
    }

    os << state.unParse();
    if (state.prefixSize > 0) {
        os << " prefix = '";

        for (unsigned i = 0; i < state.prefixSize; ++i) {
            os << state.prefix[i];
        }

        os << "'";
    }

    os << '\n';

    auto child = node->child;

    while (child != nullptr) {
        printTree(os, child, indent + 1);

        child = child->next;
    }
}

void tsioImplementation::Format::dump()
{
    for (auto node = nextNode; node != 0; node = node->next) {
        printTree(std::cout, node, 0);
    }
}

void tsio::fmt::initialize(const char* format)
{
    if (format == 0) {
        return;
    }

    if (*format == '%') {
        format++;
    }

    state.parse(format);
}

std::ostream& tsio::fmt::operator()(std::ostream& out) const
{
    using namespace tsioImplementation;

    out.width(0);
    out.precision(6);
    out.fill(' ');

    out.unsetf(std::ios::adjustfield | std::ios::basefield | std::ios::floatfield | std::ios::showbase |
               std::ios::boolalpha | std::ios::showpoint | std::ios::showpos | std::ios::uppercase);

    if (state.formatSpecifier == 0) {
        return out;
    }

    if (state.type & leftJustify) {
        out.setf(std::ios::left, std::ios::adjustfield);
    }

    if (state.type & numericfill) {
        out.fill(state.fillCharacter);
        out.setf(std::ios::internal, std::ios::adjustfield);
    }

    if (state.type & alfafill) {
        out.fill(state.fillCharacter);
    }

    if (state.type & plusIfPositive) {
        out.setf(std::ios::showpos);
    }

    if (state.type & alternative) {
        out.setf(std::ios::showpoint | std::ios::showbase);
    }

    // spaceIfPositive can not be implemented on streams
    if (state.widthGiven()) {
        out.width(state.width);
    }

    if (state.precisionGiven()) {
        out.precision(state.precision);
    }

    switch (state.formatSpecifier) {
        case 'd':
        case 'i':
        case 'u':
            break;

        case 'o':
            out.setf(std::ios::oct, std::ios::basefield);
            break;

        case 'X':
            out.setf(std::ios::uppercase);
            // Fallthru
        case 'x':
        case 'p':
            out.setf(std::ios::hex, std::ios::basefield);
            break;

        case 's':
            out.setf(std::ios::boolalpha);
            break;

        case 'E':
            out.setf(std::ios::uppercase);
            // Fallthru
        case 'e':
            out.setf(std::ios::scientific, std::ios::floatfield);
            break;

        case 'F':
            out.setf(std::ios::uppercase);
            // Fallthru
        case 'f':
            out.setf(std::ios::fixed, std::ios::floatfield);
            break;

        case 'G':
            out.setf(std::ios::uppercase);
            // Fallthru
        case 'g':
            out.unsetf(std::ios::floatfield);
            break;

        case 'A':
            out.setf(std::ios::uppercase);
            // Fallthru
        case 'a':
            out.setf(std::ios_base::fixed | std::ios_base::scientific, std::ios_base::floatfield);
            break;
    }

    return out;
}

void tsioImplementation::printfDetail(Format& format, const std::string& value)
{
    FormatState& state = format.nextNode->state;
    std::string& dest = format.dest;
    char spec = state.formatSpecifier;

    switch (spec) {
        case 's':
            outputString(dest,
                         value.c_str(),
                         value.size(),
                         state.width,
                         state.precisionGiven() ? state.precision : std::numeric_limits<int>::max(),
                         state.type,
                         state.fillCharacter);

            break;

        case 'S':
            outputString(dest,
                         value.c_str(),
                         value.size(),
                         state.width,
                         state.precisionGiven() ? state.precision : std::numeric_limits<int>::max(),
                         state.type | nice,
                         state.fillCharacter);

            break;

        default:
            std::cerr << "TSIO: Invalid format '" << spec << "' for std::string value" << std::endl;
    }
}

void tsioImplementation::printfDetail(Format& format, const char* value)
{
    FormatState& state = format.nextNode->state;
    std::string& dest = format.dest;
    char spec = state.formatSpecifier;
    uintptr_t pValue = uintptr_t(value);

    switch (spec) {
        case 'p':
            outputNumber(dest,
                         pValue,
                         16,
                         state.width,
                         state.precision,
                         state.type | alternative,
                         state.fillCharacter);

            break;

        case 's':
            outputString(dest,
                         value,
                         state.width,
                         state.precisionGiven() ? state.precision : std::numeric_limits<int>::max(),
                         state.type,
                         state.fillCharacter);

            break;

        case 'S':
            outputString(dest,
                         value,
                         state.width,
                         state.precisionGiven() ? state.precision : std::numeric_limits<int>::max(),
                         state.type | nice,
                         state.fillCharacter);

            break;

        default:
            printfDetail(format, static_cast<uintptr_t>(pValue));
    }
}

void tsioImplementation::printfDetail(Format& format, double value)
{
    FormatState& state = format.nextNode->state;
    std::string& dest = format.dest;
    char spec = state.formatSpecifier;

    switch (spec) {
        case 's':
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case 'g':
        case 'G': {
            const char* f;

            if (spec == 's') {
                FormatState newFlags(state);

                newFlags.formatSpecifier = 'g';
                f = newFlags.unParse();
            } else {
                f = state.unParse();
            }

            static char* pt = nullptr;
            static size_t allocatedSize = 0;

            int s = snprintf(pt, allocatedSize, f, value);

            if (s < 0) {
                return;
            }

            if (s >= int(allocatedSize)) {
                allocatedSize = s * 2 + 1;
                pt = static_cast<char*>(realloc(pt, allocatedSize));
                sprintf(pt, f, value);
            }

            dest.append(pt, s);
        }

        break;

        default:
            std::cerr << "TSIO: Invalid format '" << spec << "' for floating point value" << std::endl;
    }
}

void tsioImplementation::printfDetail(Format& format, float value)
{
    printfDetail(format, double(value));
}

void tsioImplementation::printfDetail(Format& format, bool value)
{
    char spec = format.nextNode->state.formatSpecifier;

    if (spec == 's') {
        const char* pt = value ? "true" : "false";

        printfDetail(format, pt);
    } else {
        printfDetail(format, static_cast<long long>(value));
    }
}

void tsioImplementation::skipAfter(const char*& format, char startChar, char endChar)
{
    const char* f = format;
    size_t count = 0;

    while (*f != 0) {
        char ch = *(f++);

        if (ch == '%') {
            ch = *(f++);

            while (ch >= '0' && ch <= '9') {
                ch = *(f++);
            }

            if (ch == startChar) {
                count++;
            } else if (ch == endChar) {
                if (count-- == 0) {
                    format = f;
                    return;
                }
            }
        }
    }

    std::cerr << "TSIO: Missing '%" << endChar << "'\n";
    format = f;
}
